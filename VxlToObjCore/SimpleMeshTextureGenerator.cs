using System;
using System.Drawing;
using System.Collections.Generic;

namespace VxlToObj.Core
{
	/// <summary>
	/// Texture generator specialized for <code>MeshSlices</code> generated by
	/// <code>SimpleMeshSliceGenerator</code>.
	/// </summary>
	public sealed class SimpleMeshTextureGenerator
	{
		public SimpleMeshTextureGenerator()
		{
		}

		private static int[] Scale2x(int[] src, int w, int h)
		{
			int[] dest = new int[w * h * 4];

			for (int y = 0; y < h; ++y)
			{
				int srci = y * w;
				int desti = srci << 2;
				for (int x = 0; x < w; ++x)
				{
					if (srci + x >= src.Length) {
						break;
					}
					dest[desti + (x << 1)] = dest[desti + (x << 1) + 1] = src[srci + x];
				}
				Buffer.BlockCopy(dest, desti << 2, dest, (desti << 2) + (w << 3), w << 3);
			}

			return dest;
		}

		public void GenerateTextureAndUV(VoxelModel model, MeshSlices slices, out Bitmap bitmap)
		{
			// Collect colors
			var colors = new List<int>(); // Marshal.Copy doesn't support uint[] lol

			foreach (var slicelist in slices)
			{
				foreach (var slice in slicelist)
				{
					var verts = slice.Positions;
					Axis3 paxis1, paxis2;
					GetPerpendicularAxises(slice.Axis, out paxis1, out paxis2);

					var pt = new IntVector3();
					pt[slice.Axis] = slice.Layer;

					foreach (var face in slice.MeshSliceFaces)
					{
						var scoord = FindSliceCoordForFace(slice, face, slice.Axis, paxis1, paxis2);
						pt[paxis1] = scoord.X;
						pt[paxis2] = scoord.Y;

						colors.Add((int) (model[pt] | 0xff000000));
					}
				}
			}

			// Determine the dimensions of the texture
			int texwidth = (int)Math.Ceiling(Math.Sqrt(colors.Count));
			int texheight = (colors.Count + texwidth - 1) / texwidth;

			// And then create the texture
			bitmap = new Bitmap(texwidth * 2, texheight * 2,
			                    System.Drawing.Imaging.PixelFormat.Format32bppRgb);
			var bmpdata = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),
										  System.Drawing.Imaging.ImageLockMode.WriteOnly,
										  System.Drawing.Imaging.PixelFormat.Format32bppRgb);


			System.Runtime.InteropServices.Marshal.Copy(Scale2x(colors.ToArray(), texwidth, texheight), 0,
														bmpdata.Scan0, colors.Count * 4);

			bitmap.UnlockBits(bmpdata);

			// Assign UVs
			int faceu = 0, facev = 0;
			foreach (var slicelist in slices)
			{
				foreach (var slice in slicelist)
				{
					var verts = slice.Positions;
					var uvs = slice.UVs = new Vector2[slice.Positions.Length];
					Axis3 paxis1, paxis2;
					GetPerpendicularAxises(slice.Axis, out paxis1, out paxis2);

					foreach (var face in slice.MeshSliceFaces)
					{
						var scoord = FindSliceCoordForFace(slice, face, slice.Axis, paxis1, paxis2);

						var uv = new Vector2((float) (faceu << 1) + 0.5f, (float) (facev << 1) + 0.5f);
						for (int i = face.StartIndex; i < face.EndIndex; ++i)
						{
							var vt = verts[i];
							float u = uv.X + (float)(vt[paxis1] - scoord.X);
							float v = uv.Y + (float)(vt[paxis2] - scoord.Y);
							uvs[i] = new Vector2(u, v);
						}

						faceu += 1;
						if (faceu == texwidth)
						{
							faceu = 0;
							facev += 1;
						}
					}
				}
			}

		}

		private static void GetPerpendicularAxises(Axis3 axis, out Axis3 paxis1, out Axis3 paxis2)
		{
			paxis1 = (Axis3)(((int)axis + 1) % 3);
			paxis2 = (Axis3)(((int)axis + 2) % 3);
		}

		private static IntVector3 FindSliceCoordForFace(MeshSlice slice, MeshSliceFace face,
		                                           Axis3 axis, Axis3 paxis1, Axis3 paxis2)
		{
			var verts = slice.Positions;
			var first = verts[face.StartIndex];
			int xmin = first[paxis1];
			int ymin = first[paxis2];
			int xmax = xmin, ymax = ymin;
			for (int i = face.StartIndex + 1; i < face.EndIndex; ++i)
			{
				var vt = verts[i];
				int x = vt[paxis1], y = vt[paxis2];
				xmin = Math.Min(xmin, x);
				ymin = Math.Min(ymin, y);
				xmax = Math.Max(xmax, x);
				ymax = Math.Max(ymax, y);
			}
			if (xmax > xmin + 1 || ymax > ymin + 1)
			{
				throw new InvalidOperationException("The input mesh has a face covering two voxels " +
													", which is not supported by " + nameof(SimpleMeshTextureGenerator) + ".");
			}
			return new IntVector3(xmin, ymin, first[axis]);
		}
	}
}

